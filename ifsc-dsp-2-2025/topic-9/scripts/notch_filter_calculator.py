#!/usr/bin/env python3
"""
Notch Filter Coefficient Calculator

Based on the Pei et al. notch filter design from dev.md
Calculates IIR notch filter coefficients for any given frequency.

Usage:
    python notch_filter_calculator.py --freq 880 --fs 48000 --rho 0.99 --alpha 0
"""

import argparse
import math
import numpy as np
from typing import Tuple, List


def calculate_notch_coefficients(f0: float, fs: float, rho: float = 0.99, alpha: float = 0.0) -> Tuple[List[float], List[float]]:
    """
    Calculate notch filter coefficients using Pei et al. method.

    Args:
        f0: Notch frequency in Hz
        fs: Sampling frequency in Hz
        rho: Pole radius (controls notch width, closer to 1 = narrower)
        alpha: Feedback parameter (0 for classical notch)

    Returns:
        Tuple of (numerator_coeffs, denominator_coeffs)
    """
    # Calculate normalized frequency
    omega_star = 2 * math.pi * f0 / fs
    cos_omega = math.cos(omega_star)

    # Calculate coefficients
    # Numerator: b = [1, -2*cos(omega*), 1]
    b0 = 1.0
    b1 = -2 * cos_omega
    b2 = 1.0

    # Denominator: a = [1, -2*(alpha+rho)/(1+alpha)*cos(omega*), (rho^2+alpha)/(1+alpha)]
    # Normalized so a0 = 1
    a0 = 1.0
    a1 = -(2 * (alpha + rho) / (1 + alpha)) * cos_omega
    a2 = (rho**2 + alpha) / (1 + alpha)

    return [b0, b1, b2], [a0, -a1, -a2]


def print_pyfda_format(b: List[float], a: List[float], f0: float, fs: float, rho: float, alpha: float):
    """Print coefficients in PyFDA format."""
    print(f"\n=== PyFDA Format (f0={f0} Hz, fs={fs} Hz, ρ={rho}, α={alpha}) ===")
    print("  |     b, a")
    for i in range(len(b)):
        print(f"{i} | {b[i]:.16f}, {a[i]:.16f}")


def print_cmsis_dsp_format(b: List[float], a: List[float], f0: float, fs: float, rho: float, alpha: float):
    """Print coefficients in CMSIS-DSP format."""
    print(f"\n=== CMSIS-DSP Format (SOS: {{b0,b1,b2,a1,a2}}) ===")
    print("// Generated by notch_filter_calculator.py")
    print(f"// f0 = {f0} Hz, fs = {fs} Hz, ρ = {rho}, α = {alpha}")
    print("#ifndef INCLUDE_COEFFS_IIR_H_")
    print("#define INCLUDE_COEFFS_IIR_H_")
    print()
    print("#include <stdint.h>")
    print()
    print("#ifndef NUM_STAGES")
    print("#define NUM_STAGES 1")
    print("#endif")
    print()
    print("static const float32_t iirCoeffsF32[NUM_STAGES*5] = {")
    print(f"    {b[0]:+.16e}f,")
    print(f"    {b[1]:+.16e}f,")
    print(f"    {b[2]:+.16e}f,")
    print(f"    {a[1]:+.16e}f,")
    print(f"    {a[2]:+.16e}f")
    print("};")
    print()
    print("#endif /* INCLUDE_COEFFS_IIR_H_ */")


def print_matlab_format(b: List[float], a: List[float], f0: float, fs: float, rho: float, alpha: float):
    """Print coefficients in MATLAB format."""
    print(f"\n=== MATLAB Format ===")
    print(f"% f0 = {f0} Hz, fs = {fs} Hz, ρ = {rho}, α = {alpha}")
    print(f"b = [{b[0]:.16f}, {b[1]:.16f}, {b[2]:.16f}];")
    print(f"a = [{a[0]:.16f}, {a[1]:.16f}, {a[2]:.16f}];")
    print(f"[H, w] = freqz(b, a, 1024, {fs});")
    print(f"plot(w, 20*log10(abs(H)));")


def print_python_format(b: List[float], a: List[float], f0: float, fs: float, rho: float, alpha: float):
    """Print coefficients in Python format."""
    print(f"\n=== Python Format ===")
    print(f"# f0 = {f0} Hz, fs = {fs} Hz, ρ = {rho}, α = {alpha}")
    print(f"b = np.array([{b[0]:.16f}, {b[1]:.16f}, {b[2]:.16f}])")
    print(f"a = np.array([{a[0]:.16f}, {a[1]:.16f}, {a[2]:.16f}])")


def calculate_frequency_response(b: List[float], a: List[float], fs: float, n_points: int = 1024) -> Tuple[np.ndarray, np.ndarray]:
    """Calculate frequency response of the filter."""
    w = np.linspace(0, fs/2, n_points)
    z = np.exp(1j * 2 * np.pi * w / fs)

    # Calculate H(z) = B(z)/A(z)
    B = b[0] + b[1]*z**(-1) + b[2]*z**(-2)
    A = a[0] + a[1]*z**(-1) + a[2]*z**(-2)
    H = B / A

    return w, H


def print_frequency_analysis(b: List[float], a: List[float], f0: float, fs: float):
    """Print frequency analysis of the filter."""
    w, H = calculate_frequency_response(b, a, fs)

    # Find the notch frequency (minimum magnitude)
    magnitude_db = 20 * np.log10(np.abs(H))
    notch_idx = np.argmin(magnitude_db)
    actual_notch_freq = w[notch_idx]
    notch_depth = magnitude_db[notch_idx]

    print(f"\n=== Frequency Analysis ===")
    print(f"Target notch frequency: {f0:.2f} Hz")
    print(f"Actual notch frequency: {actual_notch_freq:.2f} Hz")
    print(f"Notch depth: {notch_depth:.2f} dB")

    # Calculate -3dB bandwidth
    target_magnitude = magnitude_db[notch_idx] + 3
    above_target = np.where(magnitude_db > target_magnitude)[0]

    if len(above_target) > 0:
        # Find frequencies where magnitude is above target
        left_idx = above_target[above_target < notch_idx]
        right_idx = above_target[above_target > notch_idx]

        if len(left_idx) > 0 and len(right_idx) > 0:
            left_freq = w[left_idx[-1]]
            right_freq = w[right_idx[0]]
            bandwidth = right_freq - left_freq
            print(f"-3dB bandwidth: {bandwidth:.2f} Hz")
        else:
            print("-3dB bandwidth: Could not determine")


def main():
    parser = argparse.ArgumentParser(description='Calculate notch filter coefficients')
    parser.add_argument('--freq', '-f', type=float, required=True,
                       help='Notch frequency in Hz')
    parser.add_argument('--fs', type=float, default=48000,
                       help='Sampling frequency in Hz (default: 48000)')
    parser.add_argument('--rho', type=float, default=0.99,
                       help='Pole radius (0.95-0.999, closer to 1 = narrower notch)')
    parser.add_argument('--alpha', type=float, default=0.0,
                       help='Feedback parameter (0 for classical notch)')
    parser.add_argument('--format', choices=['all', 'pyfda', 'cmsis', 'matlab', 'python'],
                       default='all', help='Output format')
    parser.add_argument('--analysis', action='store_true',
                       help='Include frequency analysis')

    args = parser.parse_args()

    # Validate inputs
    if args.freq <= 0 or args.freq >= args.fs/2:
        print(f"Error: Frequency must be between 0 and {args.fs/2} Hz")
        return

    if not (0 < args.rho < 1):
        print("Error: rho must be between 0 and 1")
        return

    if args.alpha < 0:
        print("Error: alpha must be >= 0")
        return

    # Calculate coefficients
    b, a = calculate_notch_coefficients(args.freq, args.fs, args.rho, args.alpha)

    # Print results
    print(f"Notch Filter Coefficients")
    print(f"Frequency: {args.freq} Hz")
    print(f"Sampling rate: {args.fs} Hz")
    print(f"ρ (rho): {args.rho}")
    print(f"α (alpha): {args.alpha}")

    if args.format in ['all', 'pyfda']:
        print_pyfda_format(b, a, args.freq, args.fs, args.rho, args.alpha)

    if args.format in ['all', 'cmsis']:
        print_cmsis_dsp_format(b, a, args.freq, args.fs, args.rho, args.alpha)

    if args.format in ['all', 'matlab']:
        print_matlab_format(b, a, args.freq, args.fs, args.rho, args.alpha)

    if args.format in ['all', 'python']:
        print_python_format(b, a, args.freq, args.fs, args.rho, args.alpha)

    if args.analysis:
        print_frequency_analysis(b, a, args.freq, args.fs)


if __name__ == "__main__":
    main()
