#include <stm32f4xx.h>
#include <arm_math.h>
#include <stm32f4_discovery.h>
#include <stm32f4_discovery_accelerometer.h>
#include <wolfson_pi_audio.h>
#include <diag/trace.h>
#include <tests.h>
#include <dwt.h>
#include "filter.h"
#include "coeffs_IIR.h"
//#include "math_helper.h"


#define BLOCK_SIZE (WOLFSON_PI_AUDIO_TXRX_BUFFER_SIZE)/4

#undef CYCLE_COUNTER

int16_t TxBuffer[WOLFSON_PI_AUDIO_TXRX_BUFFER_SIZE];
int16_t RxBuffer[WOLFSON_PI_AUDIO_TXRX_BUFFER_SIZE];

__IO BUFFER_StateTypeDef buffer_offset = BUFFER_OFFSET_NONE;

__IO uint8_t Volume = 70;

uint32_t AcceleroTicks;
int16_t AcceleroAxis[3];

/* -------------------------------------------------------------------
 * Declare State buffer of size (4*nNUM_STAGES)
 * ------------------------------------------------------------------- */
static float32_t iirStateF32[4*NUM_STAGES];


/* ------------------------------------------------------------------
 * Global variables for IIR LPF Example
 * ------------------------------------------------------------------- */
FilterTypeDef filterType=IIR_DF1_FLOAT32;

int main(int argc, char* argv[])
{
	UNUSED(argc);
	UNUSED(argv);

	uint32_t i, k;

	float32_t inputF32Buffer[BLOCK_SIZE];
	float32_t outputF32Buffer[BLOCK_SIZE];


	// Initialise the HAL Library; it must be the first
	// instruction to be executed in the main program.
	HAL_Init();

	DWT_Enable();

  /** Configures PD15 (LED6 - Blue) as output for debug */
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* Enable GPIOD clock */
  __GPIOD_CLK_ENABLE();

  GPIO_InitStruct.Pin = GPIO_PIN_15;  // PD15 (LED6 - Blue)
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);

  HAL_Delay(1000);
  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, GPIO_PIN_SET);
  HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, GPIO_PIN_RESET);

	WOLFSON_PI_AUDIO_Init((INPUT_DEVICE_LINE_IN << 8) | OUTPUT_DEVICE_BOTH, 80, AUDIO_FREQUENCY_48K);

	WOLFSON_PI_AUDIO_SetInputMode(INPUT_DEVICE_LINE_IN);

	WOLFSON_PI_AUDIO_SetMute(AUDIO_MUTE_ON);

	WOLFSON_PI_AUDIO_Play(TxBuffer, RxBuffer, WOLFSON_PI_AUDIO_TXRX_BUFFER_SIZE);

	WOLFSON_PI_AUDIO_SetVolume(Volume);

	BSP_ACCELERO_Init();

	TEST_Init();

	arm_biquad_casd_df1_inst_f32 S;
	float32_t  *inputF32, *outputF32;

	/* Initialize input and output buffer pointers */
	inputF32 = &inputF32Buffer[0];
	outputF32 = &outputF32Buffer[0];

	/* Call IIR init function to initialize the instance structure. */
	arm_biquad_cascade_df1_init_f32(&S, NUM_STAGES, (float32_t*)iirCoeffsF32, iirStateF32);

	trace_printf("End of filter initialization.\n filterType is %d\n", filterType);

	while (1) {
		// Add your code here.
		if(buffer_offset == BUFFER_OFFSET_HALF)
		{
			HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, GPIO_PIN_SET);

			if (filterType==IIR_DF1_FLOAT32) {
				for(i=0, k=0; i<(WOLFSON_PI_AUDIO_TXRX_BUFFER_SIZE/2); i++) {
					if(i%2) {
						inputF32Buffer[k] = (float32_t)(RxBuffer[i]);//convert to float LEFT
						k++;
					}

				}
				//inputF32Buffer[0]=0.5;inputF32Buffer[1]=0.7; //for testing purposes
				arm_biquad_cascade_df1_f32(&S, inputF32, outputF32, BLOCK_SIZE);
				for(i=0, k=0; i<(WOLFSON_PI_AUDIO_TXRX_BUFFER_SIZE/2); i++) {
          TxBuffer[i] = (int16_t)(outputF32Buffer[k]);//back to 1.15
					if(i%2)	{
						k++;
					}
				}
			}

      HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, GPIO_PIN_RESET);

			buffer_offset = BUFFER_OFFSET_NONE;
		}

		if(buffer_offset == BUFFER_OFFSET_FULL)
		{
			HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, GPIO_PIN_SET);

			if (filterType==IIR_DF1_FLOAT32) {
				for(i=(WOLFSON_PI_AUDIO_TXRX_BUFFER_SIZE/2), k=0; i<WOLFSON_PI_AUDIO_TXRX_BUFFER_SIZE; i++) {
					if(i%2) {
						inputF32Buffer[k] = (float32_t)(RxBuffer[i]);//convert to float
						k++;
					}
				}
				//inputF32Buffer[0]=0.5;inputF32Buffer[1]=0.7; //for testing purposes
				arm_biquad_cascade_df1_f32(&S, inputF32, outputF32, BLOCK_SIZE);
				for(i=(WOLFSON_PI_AUDIO_TXRX_BUFFER_SIZE/2), k=0; i<WOLFSON_PI_AUDIO_TXRX_BUFFER_SIZE; i++) {
          TxBuffer[i] = (int16_t)(outputF32Buffer[k]);//back to 1.15
					if(i%2)	{
						k++;
					}
				}
			}

      HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, GPIO_PIN_RESET);

			buffer_offset = BUFFER_OFFSET_NONE;
		}

		TEST_Main();
	}
#ifdef CYCLE_COUNTER
	fclose(CycleFile);
#endif
	return 0;
}

/*--------------------------------
Callbacks implementation:
--------------------------------------------------------*/

/**
  * @brief  Manages the DMA full Transfer complete event.
  */
void WOLFSON_PI_AUDIO_TransferComplete_CallBack(void)
{
	buffer_offset = BUFFER_OFFSET_FULL;
}

/**
  * @brief  Manages the DMA Half Transfer complete event.
  */
void WOLFSON_PI_AUDIO_HalfTransfer_CallBack(void)
{
	  buffer_offset = BUFFER_OFFSET_HALF;
}

/**
  * @brief  Manages the DMA FIFO error interrupt.
  * @param  None
  * @retval None
  */
void WOLFSON_PI_AUDIO_OUT_Error_CallBack(void)
{
  /* Stop the program with an infinite loop */
  while (1);
}
